name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

jobs:
  verify-version:
    name: Verify Tag Version
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Verify tag matches Cargo.toml version
        run: |
          python - <<'PY'
          import os
          import tomllib
          with open("Cargo.toml", "rb") as f:
              data = tomllib.load(f)
          version = data["package"]["version"]
          tag = os.environ["GITHUB_REF_NAME"]
          expected = f"v{version}"
          if tag != expected:
              raise SystemExit(f"Tag {tag} does not match Cargo.toml version {expected}")
          print(f"Tag matches version: {tag}")
          PY

  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: verify-version
    env:
      MACOSX_DEPLOYMENT_TARGET: "10.15"
      MACOS_CERT_P12: ${{ secrets.MACOS_CERT_P12 }}
      MACOS_CERT_PASSWORD: ${{ secrets.MACOS_CERT_PASSWORD }}
      MACOS_SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      WINDOWS_CERT_PFX: ${{ secrets.WINDOWS_CERT_PFX }}
      WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-latest
          - macos-latest
          - windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Test
        run: cargo test --locked
      - name: Build
        run: cargo build --release --locked --bin irgen-gui
      - name: Detect arch (macOS)
        if: runner.os == 'macOS'
        run: |
          ARCH=$(uname -m)
          if [ "$ARCH" = "arm64" ]; then
            ARCH_LABEL="aarch64"
          else
            ARCH_LABEL="x86_64"
          fi
          echo "APP_ARCH=$ARCH_LABEL" >> "$GITHUB_ENV"
      - name: Install cargo-bundle (macOS)
        if: runner.os == 'macOS'
        run: cargo install cargo-bundle --locked
      - name: Bundle app (macOS)
        if: runner.os == 'macOS'
        run: cargo bundle --release
      - name: Locate app bundle (macOS)
        if: runner.os == 'macOS'
        id: app
        run: |
          APP_PATH=$(find target -maxdepth 6 -path "*bundle/osx/*.app" -print -quit)
          if [ -z "$APP_PATH" ]; then
            echo "App bundle not found under target/*/bundle/osx" >&2
            exit 1
          fi
          echo "app_path=$APP_PATH" >> "$GITHUB_OUTPUT"
          echo "app_name=$(basename "$APP_PATH" .app)" >> "$GITHUB_OUTPUT"
      - name: Import signing certificate (macOS)
        if: runner.os == 'macOS' && env.MACOS_CERT_P12 != ''
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.MACOS_KEYCHAIN_PASSWORD || 'build-pass' }}
        run: |
          echo "$MACOS_CERT_P12" | base64 -d > /tmp/cert.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security import /tmp/cert.p12 -k build.keychain -P "$MACOS_CERT_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" build.keychain
      - name: Codesign app (macOS)
        if: runner.os == 'macOS' && env.MACOS_CERT_P12 != ''
        run: |
          ENTITLEMENTS="resources/macos/entitlements.plist"
          if [ -f "$ENTITLEMENTS" ]; then
            codesign --force --deep --options runtime --timestamp \
              --entitlements "$ENTITLEMENTS" \
              --sign "$MACOS_SIGNING_IDENTITY" \
              "${{ steps.app.outputs.app_path }}"
          else
            codesign --force --deep --options runtime --timestamp \
              --sign "$MACOS_SIGNING_IDENTITY" \
              "${{ steps.app.outputs.app_path }}"
          fi
          codesign --verify --deep --strict "${{ steps.app.outputs.app_path }}"
      - name: Notarize app (macOS)
        if: runner.os == 'macOS' && env.MACOS_CERT_P12 != '' && env.APPLE_ID != ''
        run: |
          mkdir -p dist
          NOTARIZE_ZIP="dist/${{ steps.app.outputs.app_name }}-notarize.zip"
          ditto -c -k --keepParent "${{ steps.app.outputs.app_path }}" "$NOTARIZE_ZIP"
          xcrun notarytool submit "$NOTARIZE_ZIP" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait
          xcrun stapler staple "${{ steps.app.outputs.app_path }}"
      - name: Create DMG (macOS)
        if: runner.os == 'macOS'
        id: dmg
        run: |
          mkdir -p dist
          DMG_PATH="dist/Irgen-${APP_ARCH}.dmg"
          APP_PATH="${{ steps.app.outputs.app_path }}"
          VOL_NAME="${{ steps.app.outputs.app_name }}"

          workdir="$(mktemp -d)"
          stage="$workdir/stage"
          mkdir -p "$stage"
          cp -R "$APP_PATH" "$stage/"
          ln -s /Applications "$stage/Applications"

          temp_dmg="$workdir/temp.dmg"
          rm -f "$DMG_PATH"

          hdiutil create -volname "$VOL_NAME" -fs HFS+ -srcfolder "$stage" -format UDRW "$temp_dmg" >/dev/null
          attach_out="$(hdiutil attach -readwrite -noverify -noautoopen "$temp_dmg")"
          device="$(echo "$attach_out" | grep -m 1 '^/dev/' | awk '{print $1}')"
          mount_point="$(echo "$attach_out" | grep -m 1 '/Volumes/' | awk '{print $3}')"

          if [ -z "$device" ] || [ -z "$mount_point" ]; then
            echo "Failed to mount DMG" >&2
            hdiutil detach "$device" >/dev/null 2>&1 || true
            exit 1
          fi

          app_name="$(basename "$APP_PATH")"
          osascript <<EOF
          tell application "Finder"
            tell disk "$VOL_NAME"
              open
              set current view of container window to icon view
              set toolbar visible of container window to false
              set statusbar visible of container window to false
              set the bounds of container window to {200, 200, 720, 520}
              set viewOptions to the icon view options of container window
              set arrangement of viewOptions to not arranged
              set icon size of viewOptions to 128
              set position of item "$app_name" of container window to {160, 200}
              set position of item "Applications" of container window to {460, 200}
              close
              open
              update without registering applications
              delay 1
            end tell
          end tell
          EOF

          sync
          hdiutil detach "$device" >/dev/null
          hdiutil convert "$temp_dmg" -format UDZO -o "$DMG_PATH" >/dev/null
          rm -rf "$workdir"
          echo "dmg_path=$DMG_PATH" >> "$GITHUB_OUTPUT"
      - name: Notarize DMG (macOS)
        if: runner.os == 'macOS' && env.MACOS_CERT_P12 != '' && env.APPLE_ID != ''
        run: |
          xcrun notarytool submit "${{ steps.dmg.outputs.dmg_path }}" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait
          xcrun stapler staple "${{ steps.dmg.outputs.dmg_path }}"
      - name: Detect arch (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $arch = $env:PROCESSOR_ARCHITECTURE
          if ($arch -eq "ARM64") {
            $label = "aarch64"
          } else {
            $label = "x86_64"
          }
          Add-Content -Path $env:GITHUB_ENV -Value "APP_ARCH=$label"
      - name: Detect arch (Linux)
        if: runner.os == 'Linux'
        run: |
          ARCH=$(uname -m)
          if [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
            ARCH_LABEL="aarch64"
          else
            ARCH_LABEL="x86_64"
          fi
          echo "APP_ARCH=$ARCH_LABEL" >> "$GITHUB_ENV"
      - name: Build MUSL binary (Linux)
        if: runner.os == 'Linux'
        run: |
          echo "MUSL_ENABLED=false" >> "$GITHUB_ENV"
          if [ "$APP_ARCH" != "x86_64" ]; then
            echo "Skip MUSL build for unsupported arch: $APP_ARCH"
            exit 0
          fi
          sudo apt-get update
          sudo apt-get install -y musl-tools
          MUSL_TARGET="x86_64-unknown-linux-musl"
          rustup target add "$MUSL_TARGET"
          cargo build --release --locked --bin irgen-gui --target "$MUSL_TARGET"
          echo "MUSL_TARGET=$MUSL_TARGET" >> "$GITHUB_ENV"
          echo "MUSL_ENABLED=true" >> "$GITHUB_ENV"
      - name: Stage Linux binary
        if: runner.os == 'Linux'
        run: |
          mkdir -p dist
          cp target/release/irgen-gui dist/irgen-gui
          chmod +x dist/irgen-gui
          if [ "${MUSL_ENABLED:-false}" = "true" ]; then
            cp "target/${MUSL_TARGET}/release/irgen-gui" dist/irgen-gui-musl
            chmod +x dist/irgen-gui-musl
          fi
      - name: Package Linux artifacts
        if: runner.os == 'Linux'
        run: |
          TAR_PATH="dist/Irgen-${APP_ARCH}-linux.tar.gz"
          tar -C dist -czf "$TAR_PATH" irgen-gui
          if [ "${MUSL_ENABLED:-false}" = "true" ]; then
            MUSL_TAR_PATH="dist/Irgen-${APP_ARCH}-linux-musl.tar.gz"
            tar -C dist -czf "$MUSL_TAR_PATH" irgen-gui-musl
          fi
      - name: Stage Windows exe
        if: runner.os == 'Windows'
        shell: pwsh
        id: winpaths
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          $targetDir = python -c "import json,subprocess; print(json.loads(subprocess.check_output(['cargo','metadata','--format-version','1','--no-deps']))['target_directory'])"
          $exePath = Join-Path $targetDir "release\irgen-gui.exe"
          if (-not (Test-Path $exePath)) {
            Write-Host "irgen-gui.exe not found at $exePath. Searching under $targetDir..."
            $found = Get-ChildItem $targetDir -Recurse -Filter "irgen-gui.exe" -File -ErrorAction SilentlyContinue | Select-Object -First 1
            if ($found) { $exePath = $found.FullName }
          }
          if (-not (Test-Path $exePath)) {
            Write-Host "dist contents:"
            Get-ChildItem dist -Force
            Write-Host "target release exe list:"
            Get-ChildItem (Join-Path $targetDir "release") -Filter *.exe -Force -ErrorAction SilentlyContinue
            throw "irgen-gui.exe not found under $targetDir"
          }
          Copy-Item $exePath dist\irgen-gui.exe -Force
          $nsisOut = Join-Path $PWD "dist\irgen-gui-windows-setup.exe"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "exe_path=$exePath"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "nsis_out=$nsisOut"
      - name: Read app version (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $version = python -c "import tomllib; print(tomllib.load(open('Cargo.toml','rb'))['package']['version'])"
          $parts = $version.Split('.')
          while ($parts.Count -lt 3) { $parts += '0' }
          $msiVersion = "$($parts[0]).$($parts[1]).$($parts[2])"
          Add-Content -Path $env:GITHUB_ENV -Value "APP_VERSION=$version"
          Add-Content -Path $env:GITHUB_ENV -Value "APP_VERSION_MSI=$msiVersion"
      - name: Install NSIS (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install nsis -y
          $nsisPath = "${env:ProgramFiles(x86)}\NSIS"
          if (-not (Test-Path $nsisPath)) {
            $nsisPath = "${env:ProgramFiles}\NSIS"
          }
          echo "$nsisPath\Bin" | Out-File -FilePath $env:GITHUB_PATH -Append
      - name: Build installer (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $iconPath = Join-Path $PWD "resources\windows\app-icon.ico"
          makensis /DVERSION=$env:APP_VERSION /DICON_PATH="$iconPath" /DAPP_EXE_PATH="${{ steps.winpaths.outputs.exe_path }}" /DOUTFILE_PATH="${{ steps.winpaths.outputs.nsis_out }}" resources\windows\installer.nsi
      - name: Rename Windows artifacts
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $portable = "dist\\Irgen-$env:APP_ARCH-portable.exe"
          $setup = "dist\\Irgen-$env:APP_ARCH.exe"
          if (Test-Path "dist\\irgen-gui.exe") {
            Move-Item -Force "dist\\irgen-gui.exe" $portable
          }
          if (Test-Path "dist\\irgen-gui-windows-setup.exe") {
            Move-Item -Force "dist\\irgen-gui-windows-setup.exe" $setup
          }
      - name: Sign Windows artifacts
        if: runner.os == 'Windows' && env.WINDOWS_CERT_PFX != ''
        shell: pwsh
        run: |
          $pfxPath = Join-Path $env:RUNNER_TEMP "signing.pfx"
          [IO.File]::WriteAllBytes($pfxPath, [Convert]::FromBase64String($env:WINDOWS_CERT_PFX))
          $signtool = (Get-Command signtool.exe -ErrorAction SilentlyContinue).Source
          if (-not $signtool) {
            $signtool = Get-ChildItem "C:\\Program Files (x86)\\Windows Kits\\10\\bin" -Recurse -Filter signtool.exe |
              Sort-Object FullName -Descending | Select-Object -First 1 -ExpandProperty FullName
          }
          if (-not $signtool) { throw "signtool.exe not found" }
          $timestamp = "http://timestamp.digicert.com"
          $files = @("dist\Irgen-$env:APP_ARCH-portable.exe", "dist\Irgen-$env:APP_ARCH.exe")
          foreach ($file in $files) {
            if (Test-Path $file) {
              & $signtool sign /fd SHA256 /td SHA256 /tr $timestamp /f $pfxPath /p $env:WINDOWS_CERT_PASSWORD $file
            }
          }
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ runner.os }}
          path: dist/*

  release:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: dist
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            dist/**/Irgen-*.dmg
            dist/**/Irgen-*.exe
            dist/**/Irgen-*.tar.gz
